# network_profiler.py
import os
import sys
import argparse
import torch
import onnx
import numpy as np
from per_op_profiler import get_device_info, measure_gpu_energy_nvidia_smi, measure_cpu_energy

import torch.nn.functional as F
import time
import csv

# ------------------------
# Add scripts folder to sys.path (Windows import fix)
# ------------------------
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# ------------------------
# Generate dummy input
# ------------------------
def generate_dummy_input(node, graph):
    """
    Creates dummy input tensor based on node type.
    Ensures correct dimensions for Conv/MatMul/Pooling etc.
    """
    input_name = node.input[0]
    # Try to find initializer (weights) first
    for init in graph.initializer:
        if init.name == input_name:
            data = np.frombuffer(init.raw_data, dtype=np.float32)
            shape = tuple(init.dims)
            return torch.tensor(data.reshape(shape))

    # Fallback based on op type
    if node.op_type == "Conv":
        # NCHW dummy input
        return torch.randn(1, 3, 224, 224)
    elif node.op_type in ["MatMul", "Gemm", "Add"]:
        return torch.randn(10, 10)
    elif node.op_type in ["MaxPool", "GlobalAveragePool"]:
        return torch.randn(1, 3, 224, 224)
    elif node.op_type == "Flatten":
        return torch.randn(1, 3, 224, 224)
    else:
        return torch.randn(1, 1)

# ------------------------
# Map ONNX op to PyTorch function
# ------------------------
def get_torch_op(node_type):
    if node_type == "Relu":
        return torch.relu
    elif node_type == "Sigmoid":
        return torch.sigmoid
    elif node_type == "Tanh":
        return torch.tanh
    elif node_type == "MatMul":
        return lambda x: torch.matmul(x, x.T if x.dim() == 2 else x)
    elif node_type == "Add":
        return lambda x: x + x
    elif node_type == "Conv":
        return lambda x: F.conv2d(x, torch.randn(1, x.shape[1], 3, 3))
    elif node_type == "MaxPool":
        return lambda x: F.max_pool2d(x, kernel_size=2, stride=2)
    elif node_type == "GlobalAveragePool":
        return lambda x: x.mean(dim=(2,3), keepdim=True)
    elif node_type == "Flatten":
        return lambda x: x.view(x.size(0), -1)
    elif node_type == "Gemm":
        return lambda x: torch.matmul(x, x.T if x.dim() == 2 else x)
    else:
        return None  # unsupported op

# ------------------------
# Save results to CSV
# ------------------------
def save_results_csv(results, csv_file):
    if not results:
        print("No results to save.")
        return
    file_exists = os.path.isfile(csv_file)
    with open(csv_file, "a", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=results[0].keys())
        if not file_exists:
            writer.writeheader()
        for r in results:
            writer.writerow(r)

# ------------------------
# Profile network per-op
# ------------------------
def profile_network_per_op(onnx_model_path, device, runs=10, csv_file="network_profile.csv", dtype="float32"):
    # Load ONNX model
    model = onnx.load(onnx_model_path)
    graph = model.graph

    results = []

    for node in graph.node:
        op_type = node.op_type
        func = get_torch_op(op_type)
        if func is None:
            print(f"Skipping unsupported op: {op_type}")
            continue

        # Generate dummy input
        input_tensor = generate_dummy_input(node, graph).to(device)

        # Warm-up
        for _ in range(3):
            out = func(input_tensor)

        # Measure time + energy
        times = []
        if device.type == "cuda":
            torch.cuda.synchronize()
            avg_power, total_energy = measure_gpu_energy_nvidia_smi(duration=1.0, device_index=device.index if hasattr(device,'index') else 0)
        else:
            avg_power, total_energy = measure_cpu_energy(duration=1.0)

        for _ in range(runs):
            t0 = time.time()
            out = func(input_tensor)
            if device.type == "cuda":
                torch.cuda.synchronize()
            t1 = time.time()
            times.append((t1 - t0) * 1000.0)  # ms

        avg_time_ms = sum(times)/len(times)
        device_type, device_name = get_device_info(device)

        result = {
            "op_type": op_type,
            "input_shape": tuple(input_tensor.shape),
            "device_type": device_type,
            "device_name": device_name,
            "precision": dtype,
            "avg_time_ms": avg_time_ms,
            "avg_power_w": avg_power,
            "total_energy_j": total_energy
        }

        results.append(result)
        print(f"Profiled op: {op_type}")

    save_results_csv(results, csv_file)
    print(f"Per-op profiling complete. Results saved to {csv_file}")

# ------------------------
# Main
# ------------------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--model", required=True, help="Path to ONNX model")
    parser.add_argument("--device", default=None, choices=["cpu","cuda"], help="Device to run on")
    parser.add_argument("--runs", type=int, default=10, help="Number of iterations")
    parser.add_argument("--csv", default="network_profile.csv", help="CSV output file")
    parser.add_argument("--dtype", default="float32", help="Tensor precision")
    args = parser.parse_args()

    device = torch.device(args.device or ("cuda" if torch.cuda.is_available() else "cpu"))
    profile_network_per_op(args.model, device, runs=args.runs, csv_file=args.csv, dtype=args.dtype)

if __name__ == "__main__":
    main()
